# Copilot Instructions for Life Planner

## Project Overview

Life Planner is a comprehensive life organization mobile application built with Expo/React Native that helps families manage multiple aspects of their lives including finances, personal storage, family schedules, and more. The app supports iOS, Android, and Web platforms.

## Architecture

This project follows **Clean Architecture** principles with clear separation of concerns:

### Folder Structure

```
app/                     # Expo router routes and navigation
src/
├── application/         # Use cases and business logic
│   ├── dto/            # Data Transfer Objects
│   ├── providers/      # Application-level providers
│   └── useCases/       # Business use cases
├── data/               # Data layer - communication with backend
│   ├── datasource/     # Data sources (Supabase)
│   ├── models/         # Data models
│   └── repositories/   # Repository implementations
├── domain/             # Core business entities and interfaces
│   ├── entities/       # Business entities
│   └── repositories/   # Repository interfaces
├── infrastructure/     # External libraries and system concerns
│   ├── crypto/         # Cryptography utilities
│   ├── date/           # Date utilities
│   ├── fetcher/        # Data fetching abstractions
│   ├── googleOAuth/    # Google OAuth integration
│   ├── monitoring/     # Sentry monitoring
│   └── storage/        # Local storage abstractions
├── navigation/         # Router initialization
├── presentation/       # UI layer
│   ├── components/     # Reusable UI components
│   ├── screens/        # Application screens
│   ├── i18n/          # Internationalization
│   └── theme/         # UI theme and styling
├── providers/          # Cross-layer provider connections
└── utils/             # General utilities
```

### Architecture Principles

1. **Dependency Inversion**: Higher-level modules don't depend on lower-level modules
2. **Interface Segregation**: Use specific interfaces for different concerns
3. **Single Responsibility**: Each class/module has one reason to change
4. **Repository Pattern**: Abstract data access through repository interfaces

## Technology Stack

- **Framework**: Expo SDK 52 with React Native 0.76
- **Language**: TypeScript
- **Backend**: Supabase (Database, Auth, Storage)
- **State Management**: React Query (@tanstack/react-query)
- **Navigation**: Expo Router with React Navigation
- **UI Library**: React Native Paper + @rneui/themed
- **Testing**: Jest with React Native Testing Library
- **Code Quality**: ESLint + Prettier + Husky
- **Package Manager**: Yarn 4.6.0 (with Corepack)
- **Monitoring**: Sentry
- **Internationalization**: react-i18next

## Development Guidelines

### Code Organization

1. **Feature-based Structure**: Group related files by feature when possible
2. **Layer Separation**: Respect architectural boundaries
3. **Naming Conventions**:
   - Use PascalCase for components and classes
   - Use camelCase for functions and variables
   - Use kebab-case for file names
   - Suffix test files with `.test.ts(x)`

### React Native Patterns

```typescript
// Component structure
interface ComponentProps {
  // Define props with TypeScript
}

export function Component({ prop }: ComponentProps) {
  // Hooks at the top
  // Logic in the middle
  // Return JSX at the bottom
}
```

### Repository Pattern Implementation

```typescript
// Domain layer - interface
export interface UserRepository {
  getUser(id: string): Promise<User>;
}

// Data layer - implementation
export class UserRepositoryImpl implements UserRepository {
  async getUser(id: string): Promise<User> {
    // Implementation using Supabase
  }
}
```

### Use Case Pattern

```typescript
export class GetUserUseCase {
  constructor(private userRepository: UserRepository) {}

  async execute(userId: string): Promise<UserDTO> {
    // Business logic here
  }
}
```

### Testing Patterns

1. **Unit Tests**: Test individual functions and classes
2. **Integration Tests**: Test layer interactions
3. **Component Tests**: Test React components with React Native Testing Library
4. **Mocking**: Use mocks for external dependencies

### Data Flow

1. **UI Layer** → **Use Cases** → **Repositories** → **Data Sources**
2. Use React Query for caching and synchronization
3. Use DTOs for data transformation between layers
4. Handle errors at appropriate levels

## Common Patterns

### Error Handling

```typescript
try {
  const result = await useCase.execute(params);
  return success(result);
} catch (error) {
  monitoring.capture(error);
  return failure(error);
}
```

### React Query Integration

```typescript
export function useGetUser(userId: string) {
  return useQuery({
    queryKey: [getUserUseCase.uniqueName, userId],
    queryFn: () => getUserUseCase.execute(userId),
  });
}
```

### Internationalization

```typescript
import { useTranslation } from '@presentation/i18n';

export function Component() {
  const { t } = useTranslation();
  return <Text>{t('common.welcome')}</Text>;
}
```

## Development Workflow

1. **Install**: `yarn install` (requires Corepack)
2. **Start Development**: `yarn expo start`
3. **Run Tests**: `yarn test`
4. **Lint**: `yarn lint`
5. **Platform-specific**:
   - iOS: `yarn ios`
   - Android: `yarn android`
   - Web: `yarn web`

## Key Conventions

1. **Clean Architecture**: Always respect layer boundaries
2. **TypeScript**: Use strict typing, avoid `any`
3. **Testing**: Write tests for new features and bug fixes
4. **i18n**: All user-facing strings should be translatable
5. **Performance**: Use FlashList for large lists, optimize images
6. **Accessibility**: Follow React Native accessibility guidelines
7. **Error Boundaries**: Implement proper error handling
8. **Monitoring**: Log important events and errors to Sentry

## File Naming

- Components: `ComponentName/index.tsx`
- Tests: `ComponentName.test.tsx`
- Types: `types.ts` or inline interfaces
- Hooks: `useHookName.ts`
- Utils: `utilityName.ts`

## Import Patterns

```typescript
// External libraries first
import React from "react";
import { View } from "react-native";

// Internal imports with absolute paths
import { UserEntity } from "@domain/entities";
import { useGetUser } from "@application/useCases";
import { Button } from "@presentation/components";

// Relative imports for same-level files
import "./styles.css";
```

When contributing to this project, ensure all changes maintain the Clean Architecture principles and include appropriate tests, typecheck and linter checks. Follow the established patterns for consistency and maintainability.

Run before committing:

```bash
yarn lint-staged
yarn type-check
yarn test --passWithNoTests $(git diff --name-only --cached | xargs)
```

and ensure everything is working as expected.
